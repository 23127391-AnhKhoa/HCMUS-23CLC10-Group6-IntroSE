/** * File Validation Utilities *  * @file fileValidation.js * @description Utility functions for file validation * Pure functions without side effects, can be used anywhere */const path = require('path');/** * File type configurations */const FILE_TYPES = {  IMAGES: {    extensions: ['jpg', 'jpeg', 'png', 'gif', 'webp'],    mimeTypes: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp']  },  DOCUMENTS: {    extensions: ['pdf', 'doc', 'docx', 'txt'],    mimeTypes: [      'application/pdf',      'application/msword',      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',      'text/plain'    ]  },  ARCHIVES: {    extensions: ['zip', 'rar', '7z'],    mimeTypes: [      'application/zip',      'application/x-rar-compressed',      'application/x-zip-compressed',      'application/x-7z-compressed'    ]  },  VIDEOS: {    extensions: ['mp4', 'mov', 'avi'],    mimeTypes: ['video/mp4', 'video/quicktime', 'video/x-msvideo']  }};/** * Get file extension from filename * @param {string} filename - File name * @returns {string} File extension in lowercase */const getFileExtension = (filename) => {  if (!filename) return '';  return path.extname(filename).toLowerCase().slice(1);};/** * Check if file extension is allowed * @param {string} filename - File name * @param {Array} allowedExtensions - Allowed extensions array * @returns {boolean} True if extension is allowed */const isExtensionAllowed = (filename, allowedExtensions = []) => {  if (allowedExtensions.length === 0) return true;  const extension = getFileExtension(filename);  return allowedExtensions.includes(extension);};/** * Check if MIME type is allowed * @param {string} mimetype - File MIME type * @param {Array} allowedMimeTypes - Allowed MIME types array * @returns {boolean} True if MIME type is allowed */const isMimeTypeAllowed = (mimetype, allowedMimeTypes = []) => {  if (allowedMimeTypes.length === 0) return true;  return allowedMimeTypes.includes(mimetype);};/** * Validate single file with enhanced .png support * @param {Object} file - File object with originalname, mimetype, size * @param {Object} options - Validation options * @returns {Object} Validation result */const validateFile = (file, options = {}) => {  const {    maxFileSize = 10 * 1024 * 1024, // 10MB    allowedExtensions = [],    allowedMimeTypes = [],    strictValidation = false // If false, pass if either extension OR mimetype is valid  } = options;  const errors = [];  // Size validation  if (file.size > maxFileSize) {    errors.push(`File "${file.originalname}" exceeds maximum size of ${Math.round(maxFileSize / (1024 * 1024))}MB`);  }  // Type validation with dual approach for .png compatibility  const extensionValid = isExtensionAllowed(file.originalname, allowedExtensions);  const mimeTypeValid = isMimeTypeAllowed(file.mimetype, allowedMimeTypes);  if (strictValidation) {    // Both must be valid    if (!extensionValid || !mimeTypeValid) {      errors.push(`File "${file.originalname}" has invalid type`);    }  } else {    // Either extension OR mimetype must be valid (handles .png MIME type issues)    if (!extensionValid && !mimeTypeValid) {      errors.push(`File "${file.originalname}" has invalid type`);    }  }  return {    valid: errors.length === 0,    errors,    metadata: {      extension: getFileExtension(file.originalname),      mimetype: file.mimetype,      extensionValid,      mimeTypeValid    }  };};/** * Validate multiple files * @param {Array} files - Array of file objects * @param {Object} options - Validation options * @returns {Object} Validation result */const validateFiles = (files, options = {}) => {  const {    maxFiles = 10,    maxTotalSize = 50 * 1024 * 1024, // 50MB    ...fileOptions  } = options;  const errors = [];  const validatedFiles = [];  // Check file count  if (files.length > maxFiles) {    errors.push(`Maximum ${maxFiles} files allowed, got ${files.length}`);  }  // Check total size  const totalSize = files.reduce((sum, file) => sum + file.size, 0);  if (totalSize > maxTotalSize) {    errors.push(`Total size ${Math.round(totalSize / (1024 * 1024))}MB exceeds maximum ${Math.round(maxTotalSize / (1024 * 1024))}MB`);  }  // Validate each file  files.forEach((file, index) => {    const result = validateFile(file, fileOptions);    validatedFiles.push({      index,      file: file.originalname,      ...result    });    if (!result.valid) {      errors.push(...result.errors);    }  });  return {    valid: errors.length === 0,    errors,    files: validatedFiles,    summary: {      totalFiles: files.length,      totalSize: Math.round(totalSize / (1024 * 1024)),      validFiles: validatedFiles.filter(f => f.valid).length    }  };};/** * Preset validation configurations */const VALIDATION_PRESETS = {  delivery: {    maxFileSize: 10 * 1024 * 1024,    maxTotalSize: 50 * 1024 * 1024,    maxFiles: 10,    allowedExtensions: [      ...FILE_TYPES.IMAGES.extensions,      ...FILE_TYPES.DOCUMENTS.extensions,      ...FILE_TYPES.ARCHIVES.extensions    ],    allowedMimeTypes: [      ...FILE_TYPES.IMAGES.mimeTypes,      ...FILE_TYPES.DOCUMENTS.mimeTypes,      ...FILE_TYPES.ARCHIVES.mimeTypes    ]  },  profileImage: {    maxFileSize: 5 * 1024 * 1024,    maxTotalSize: 5 * 1024 * 1024,    maxFiles: 1,    allowedExtensions: FILE_TYPES.IMAGES.extensions,    allowedMimeTypes: FILE_TYPES.IMAGES.mimeTypes  },  gigMedia: {    maxFileSize: 20 * 1024 * 1024,    maxTotalSize: 100 * 1024 * 1024,    maxFiles: 5,    allowedExtensions: [      ...FILE_TYPES.IMAGES.extensions,      ...FILE_TYPES.VIDEOS.extensions    ],    allowedMimeTypes: [      ...FILE_TYPES.IMAGES.mimeTypes,      ...FILE_TYPES.VIDEOS.mimeTypes    ]  }};/** * Get preset validation options * @param {string} presetName - Preset name * @param {Object} overrides - Override options * @returns {Object} Validation options */const getPreset = (presetName, overrides = {}) => {  const preset = VALIDATION_PRESETS[presetName];  if (!preset) {    throw new Error(`Unknown validation preset: ${presetName}`);  }  return { ...preset, ...overrides };};module.exports = {  // Core functions  validateFile,  validateFiles,    // Helper functions  getFileExtension,  isExtensionAllowed,  isMimeTypeAllowed,    // Presets  getPreset,  VALIDATION_PRESETS,  FILE_TYPES};